(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{414:function(e,r,t){"use strict";t.r(r);var n=t(2),o=Object(n.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("compose函数可以将需要嵌套执行的函数平铺，嵌套执行就是一个函数的返回值将作为另一个函数的参数。\n所以compose函数可以是以下这种形式")]),e._v(" "),r("p",[e._v("let res = compose(multiply, add)(10);")]),e._v(" "),r("p",[e._v("在讲这个之前我们先来看一个需要用到的函数Array.prototype.reduce")]),e._v(" "),r("p",[e._v("Array.prototype.reduce\n数组的reduce方法可以实现一个累加效果，它接收两个参数，第一个是一个累加器方法，第二个是初始化值。累加器接收四个参数，第一个是上次的计算值，第二个是数组的当前值，主要用的就是这两个参数，后面两个参数不常用，他们是当前index和当前迭代的数组：")]),e._v(" "),r("p",[e._v("const arr = [[1, 2], [3, 4], [5, 6]];\n// prevRes的初始值是传入的[]，以后会是每次迭代计算后的值\nconst flatArr = arr.reduce((prevRes, item) => prevRes.concat(item), []);")]),e._v(" "),r("p",[e._v("console.log(flatArr); // [1, 2, 3, 4, 5, 6]\nArray.prototype.reduceRight\nArray.prototype.reduce会从左往右进行迭代，如果需要从右往左迭代，用Array.prototype.reduceRight就好了")]),e._v(" "),r("p",[e._v("const arr = [[1, 2], [3, 4], [5, 6]];\n// prevRes的初始值是传入的[]，以后会是每次迭代计算后的值\nconst flatArr = arr.reduceRight((prevRes, item) => prevRes.concat(item), []);")]),e._v(" "),r("p",[e._v("console.log(flatArr); // [5, 6, 3, 4, 1, 2]\n那这个compose方法要怎么实现呢，这里需要借助Array.prototype.reduceRight:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const compose = function(){\n  // 将接收的参数存到一个数组， args == [multiply, add]\n  const args = [].slice.apply(arguments);\n  return function(x) {\n    return args.reduceRight((res, cb) => cb(res), x);\n  }\n}\n\n// 我们来验证下这个方法\nlet calculate = compose(multiply, add);\nlet res = calculate(10);\nconsole.log(res);    // 结果还是200\n")])])])])}),[],!1,null,null,null);r.default=o.exports}}]);