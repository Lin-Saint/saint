(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{422:function(n,e,a){"use strict";a.r(e);var t=a(2),s=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[n._v("#")]),n._v(" 定义")]),n._v(" "),e("p",[n._v("发布-订阅模式其实是一种对象间一对多的依赖关系，当一个对象的状态发送改变时，所有依赖于它的对象都将得到状态改变的通知。\n订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。")]),n._v(" "),e("h1",{attrs:{id:"思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[n._v("#")]),n._v(" 思路")]),n._v(" "),e("p",[n._v("创建一个 EventEmitter 类\n在该类上创建一个事件中心（Map）\non 方法用来把函数 fn 都加到事件中心中（订阅者注册事件到调度中心）\nemit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应事件中心中的函数（发布者发布事件到调度中心，调度中心处理代码）\noff 方法可以根据 event 值取消订阅（取消订阅）\nonce 方法只监听一次，调用完毕后删除缓存函数（订阅一次）\n注册一个 newListener 用于监听新的事件订阅")]),n._v(" "),e("p",[n._v("第一步，创建一个类，并初始化一个事件存储中心")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class EventEmitter{\n    // 用来存放注册的事件与回调\n    constructor(){\n        this._events = {};\n    }\n}\n")])])]),e("p",[n._v("第二步，实现事件的订阅方法 on")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class EventEmitter{\n    // 用来存放注册的事件与回调\n    constructor(){\n        this._events = {};\n    }\n\n    on(eventName, callback){\n        // 由于一个事件可能注册多个回调函数，所以使用数组来存储事件队列\n        const callbacks = this._events[eventName] || [];\n        callbacks.push(callback);\n        this._events[eventName] = callbacks\n    }\n}\n")])])]),e("p",[n._v("第三步，实现事件的发布方法 emit")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class EventEmitter{\n    // 用来存放注册的事件与回调\n    constructor(){\n        this._events = {};\n    }\n\n    // args 用于收集发布事件时传递的参数\n    emit(eventName, ...args){\n        const callbacks = this._events[eventName] || [];\n        callbacks.forEach(cb => cb(...args))\n    }\n}\n")])])]),e("p",[n._v("第四步，实现事件的取消订阅方法 off")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class EventEmitter{\n    // 用来存放注册的事件与回调\n    constructor(){\n        this._events = {};\n    }\n    \n    \n    off(eventName, callback){\n        const callbacks = this._events[eventName] || []\n\n        const newCallbacks = callbacks.filter(fn => fn != callback && fn.initialCallback != callback /* 用于once的取消订阅 */)\n\n        this._events[eventName] = newCallbacks;\n    }\n}\n")])])]),e("p",[n._v("第五步，实现事件的单次订阅方法 once")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class EventEmitter{\n    // 用来存放注册的事件与回调\n    constructor(){\n        this._events = {};\n    }\n    \n    // \n    once(eventName, callback){\n        // 由于需要在回调函数执行后，取消订阅当前事件，所以需要对传入的回调函数做一层包装,然后绑定包装后的函数\n        const one = (...args)=>{\n            // 执行回调函数\n            callback(...args)\n            // 取消订阅当前事件\n            this.off(eventName, one)\n        }\n       \n\n\n\n        // 由于：我们订阅事件的时候，修改了原回调函数的引用，所以，用户触发 off 的时候不能找到对应的回调函数\n        // 所以，我们需要在当前函数与用户传入的回调函数做一个绑定，我们通过自定义属性来实现\n        one.initialCallback = callback;\n        this.on(eventName, one)\n    }\n}\n")])])]),e("p",[n._v("完整代码")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("class EventEmitter{\n    constructor(){\n        this._events = {};\n    }\n\n    on(eventName, callback){\n        \n        const callbacks = this._events[eventName] || [];\n        callbacks.push(callback);\n        this._events[eventName] = callbacks\n    }\n\n    emit(eventName, ...args){\n        const callbacks = this._events[eventName] || [];\n        callbacks.forEach(cb => cb(...args))\n    }\n\n    once(eventName, callback){\n        const one = (...args)=>{\n            callback(...args)\n            this.off(eventName, one)\n        }\n        one.initialCallback = callback;\n        this.on(eventName, one)\n    }\n\n     off(eventName, callback){\n        const callbacks = this._events[eventName] || []\n        const newCallbacks = callbacks.filter(fn => fn != callback && fn.initialCallback != callback /* 用于once的取消订阅 */)\n        this._events[eventName] = newCallbacks;\n    }\n}\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);