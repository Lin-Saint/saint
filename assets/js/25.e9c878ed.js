(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{415:function(n,t,r){"use strict";r.r(t);var s=r(2),a=Object(s.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"柯里化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[n._v("#")]),n._v(" 柯里化")]),n._v(" "),t("p",[n._v("柯里化就是将一个接收多个参数的函数转化为一系列使用一个参数的函数的技术。")]),n._v(" "),t("p",[n._v("比如下面这个例子")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const fn = (x,y,z) => {\n    console.log(x+y+z)\n}\n")])])]),t("p",[n._v("其实就是一直接收参数，直到参数都接收完了就执行函数。\n获取一个函数的参数个数可以用到length属性 比如上面的：fn.length")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("const curry = (fn) => {\n    const argNum = fn.length\n    return function excutor(...args) {\n        if(args.length >= argNum) {\n            return fn(...args)\n        } else {\n            return (...args2) => {\n                return excutor(...args.concat(args2))\n            }\n        }\n    }\n}\n\n\n//测试代码\nconst fn = (x,y,z) => {\n    console.log(x+y+z)\n}\n\nconst curryfn = curry(fn);\n\ncurryfn(1)(2,3)\ncurryfn(1)(2)(3)\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);