(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{419:function(n,e,t){"use strict";t.r(e);var o=t(2),s=Object(o.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("async function asyncPool(limit, array, iteratorFn) {\n  const ret = [];  //存放promise，一开始状态为pending\n  const executing = []; //并发控制池\n  for (const item of array) {\n    const p = iteratorFn(item); \n    ret.push(p);\n    if (limit <= array.length) {\n      const e = p.then(() => { \n        console.log('正在运行' + executing.length)\n        executing.splice(executing.indexOf(e), 1) //当p有了结果之后将并发控制池中的自己移除，以便后面继续添加来维持并发数量\n      });\n      executing.push(e);\n      if (executing.length >= limit) {\n        await Promise.race(executing); //等待并发控制中最先完成的请求，再继续for循环的下一个遍历对象\n      }\n    }\n  }\n  return Promise.all(ret);\n}\n \n \n \n \nconst timeout = (i) => {\n  console.log('开始' + i);\n \n  return new Promise((resolve) => setTimeout(() => {\n    resolve(i);\n    console.log('结束' + i);\n  }, 1000+Math.random()*1000));\n};\n \nlet urls = Array(10).fill(0).map((v,i)=>i)\nconsole.log(urls);\n(async () => {\n    const res = await asyncPool(3, urls, timeout);\n    console.log(res);\n })()\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);