(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{412:function(n,t,o){"use strict";o.r(t);var e=o(2),a=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"bind"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bind"}},[n._v("#")]),n._v(" bind")]),n._v(" "),t("p",[n._v("bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )")]),n._v(" "),t("p",[n._v("返回的函数也是可以传参的")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    console.log(this.value);\n    console.log(name);\n    console.log(age);\n}\n\nvar bindFoo = bar.bind(foo, 'daisy');\nbindFoo('18');\n\n")])])]),t("h1",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[n._v("#")]),n._v(" 实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nFunction.prototype.bind2 = function (context) {\n\n    var self = this;\n    // 获取bind2函数从第二个参数到最后一个参数(第一个参数是context，不需要)\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    return function () {\n        // 这个时候的arguments是指bind返回的函数传入的参数\n        var bindArgs = Array.prototype.slice.call(arguments);\n        return self.apply(context, args.concat(bindArgs));\n    }\n\n}\n\n")])])]),t("p",[n._v("关于bind，最难的地方：一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。看代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var value = 2;\n\nvar foo = {\n    value: 1\n};\n\nfunction bar(name, age) {\n    this.habit = 'shopping';\n    console.log(this.value);\n    console.log(name);\n    console.log(age);\n}\n\nbar.prototype.friend = 'kevin';\n\nvar bindFoo = bar.bind(foo, 'daisy');\n\nvar obj = new bindFoo('18');\n// undefined\n// daisy\n// 18\nconsole.log(obj.habit);\nconsole.log(obj.friend);\n// shopping\n// kevin\n\n")])])]),t("p",[n._v("可以通过修改返回函数的原型来实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n\nFunction.prototype.bind2 = function (context) {\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var fBound = function () {\n        var bindArgs = Array.prototype.slice.call(arguments);\n        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值\n        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性\n        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context\n        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));\n    }\n    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值\n    fBound.prototype = this.prototype;\n    return fBound;\n}\n\n\n")])])]),t("p",[n._v("但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。看例子:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("Function.prototype.bind2 = function (context) {\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var fBound = function () {\n        var bindArgs = Array.prototype.slice.call(arguments);\n        self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));\n    }\n    fBound.prototype = this.prototype;\n    return fBound;\n}\n\n\nfunction bar() {}\n\nvar bindFoo = bar.bind2(null);\n\nbindFoo.prototype.value = 1;\n\nconsole.log(bar.prototype.value) // 1\n\n")])])]),t("p",[n._v("明明修改的是 bindFoo.prototype ，但是 bar.prototype 的值也被修改了，这就是因为 fBound.prototype = this.prototype导致的。")]),n._v(" "),t("p",[n._v("解决这个问题可以利用一个函数进行空转")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('Function.prototype.bind2 = function (context) {\n\n    if (typeof this !== "function") {\n      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");\n    }\n\n    var self = this;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var fNOP = function () {};\n\n    var fBound = function () {\n        var bindArgs = Array.prototype.slice.call(arguments);\n        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));\n    }\n\n    fNOP.prototype = this.prototype;\n    fBound.prototype = new fNOP();\n    return fBound;\n}\n\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//上面利用一个空函数进行空转的这段代码其实就是模拟Object.create(),用es6的写法可以直接 \n    \n    //fBound.prototype = Object.create(this.prototype)\n\n    Object.create = function( o ) {\n        function f(){}\n        f.prototype = o;\n        return new f;\n    };\n\n    //还有一处问题, this instanceof fNOP,这里其实写fNOP或者fBound都可以\n    function Fnop() {\n        this.name = 'lin'\n    }\n\n    function Bound() {\n        this.age = '18'\n    }\n\n\n    Bound.prototype = new Fnop();\n\n    var o = new Bound();\n\n    o instanceof Fnop //true\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);